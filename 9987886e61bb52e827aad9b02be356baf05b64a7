{
  "comments": [
    {
      "key": {
        "uuid": "ada5c809_e6b31f9e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000014
      },
      "writtenOn": "2020-07-23T16:31:01Z",
      "side": 1,
      "message": "Of the alternatives, adding the additional tools seems cleanest. Do we really need C and Objective-C modules though? I wouldn\u0027t have expected these could go into C++ modules.",
      "revId": "9987886e61bb52e827aad9b02be356baf05b64a7",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "98b29be2_2174feb9",
        "filename": "src/gn/ninja_c_binary_target_writer.cc",
        "patchSetId": 1
      },
      "lineNbr": 347,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2020-07-23T02:51:04Z",
      "side": 1,
      "message": "Why is any of this built in?  Shouldn\u0027t this all be part of a tool definition?",
      "range": {
        "startLine": 342,
        "startChar": 0,
        "endLine": 347,
        "endChar": 0
      },
      "revId": "9987886e61bb52e827aad9b02be356baf05b64a7",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f51b9f97_a4e3fdde",
        "filename": "src/gn/ninja_c_binary_target_writer.cc",
        "patchSetId": 1
      },
      "lineNbr": 347,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-07-23T03:02:27Z",
      "side": 1,
      "message": "Yes, the issue is that these flags only apply to modules. Specifically some of these flags apply to module compilation itself which is a separate rule, some apply to any C/C++/Objective-C rule that uses modules and I haven\u0027t quite figured the most elegant way to express this.\n\nOne idea I\u0027ve experimented with was having a dedicated tool (e.g. cc_module) and put these flags there. The downside was that it was quite verbose since you need at least 4 different tools: cc_module, cxx_module, objc_module, objcxx_module.\n\nAnother idea I considered is to introduce another variable, e.g. cflags_modules, which would contain flags that are used for compiling modules. The issue is that -fmodule-name\u003d contains the module name which has to match the name in the modulemap file and for autogenerated modulemap files, it\u0027d be the label. Ideally we would use -fmodule-name\u003d{{module_name}} expansion, but expansions cannot be used in configs, at least no today.\n\nDo you have any other ideas?",
      "parentUuid": "98b29be2_2174feb9",
      "range": {
        "startLine": 342,
        "startChar": 0,
        "endLine": 347,
        "endChar": 0
      },
      "revId": "9987886e61bb52e827aad9b02be356baf05b64a7",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "46f9c2cb_f2378129",
        "filename": "src/gn/ninja_c_binary_target_writer.cc",
        "patchSetId": 1
      },
      "lineNbr": 347,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-07-23T03:08:13Z",
      "side": 1,
      "message": "I forgot another idea I also considered which would be to have a toolchain variable akin to     lib_switch or lib_dir_switch, like this:\n\n  module_name_switch \u003d \"-fmodule-name\u003d\"\n\nProblem is that there are other flags like `-fmodule-map-file\u003d` and `-fmodule-file\u003d` which have to be specified for every module dependency, see src/gn/ninja_target_command_util.cc below. We could do:\n\n  module_map_file_switch \u003d \"-fmodule-map-file\u003d\"\n  module_file_switch \u003d \"-fmodule-file\u003d\"\n\nbut it seems a bit verbose, but maybe it\u0027s not so bad?",
      "parentUuid": "f51b9f97_a4e3fdde",
      "range": {
        "startLine": 342,
        "startChar": 0,
        "endLine": 347,
        "endChar": 0
      },
      "revId": "9987886e61bb52e827aad9b02be356baf05b64a7",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6582b067_82479638",
        "filename": "src/gn/ninja_c_binary_target_writer.cc",
        "patchSetId": 1
      },
      "lineNbr": 347,
      "author": {
        "id": 1000016
      },
      "writtenOn": "2020-07-23T03:10:21Z",
      "side": 1,
      "message": "The separate tool is most consistent with the existing GN features.  There is a lot of duplication between link, solink, and solink_module too, and a fair bit between cc and cxx.  I think toolchain writers just have to expect that and write template code and whatnot to manage it, as we\u0027ve all done heretofore.\n\nThat said, being able to do some kinds of substitutions in flags specified outside the tool (i.e. in configs or directly in targets) would probably be useful generally.  But perhaps most useful if the expansions you could use were generalized somehow as a user feature.  That seems like a bigger revamp of GN semantics than you might want to get into as a blocker for the modules support.\n\nI found it hard to follow from either the code, the help text, or the example gn files exactly what the new features are and how they work, so some more thorough explanation of the details somewhere would be helpful.",
      "parentUuid": "f51b9f97_a4e3fdde",
      "range": {
        "startLine": 342,
        "startChar": 0,
        "endLine": 347,
        "endChar": 0
      },
      "revId": "9987886e61bb52e827aad9b02be356baf05b64a7",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "64fd460e_38e8c3ab",
        "filename": "src/gn/ninja_c_binary_target_writer.cc",
        "patchSetId": 1
      },
      "lineNbr": 347,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-07-23T03:19:00Z",
      "side": 1,
      "message": "I agree about the bigger revamp, ideally we would have something like Bazel\u0027s features (https://docs.bazel.build/versions/master/cc-toolchain-config-reference.html) which would allow us to do things like:\n\n  features \u003d [\n    feature(\n        name \u003d \"module_file\",\n        requires \u003d [with_feature_set(features \u003d [\"modules\"])],\n        flag_sets \u003d [\n            flag_set(\n                actions \u003d [\"ACTION_NAMES.c_compile\", \"ACTION_NAMES.cpp_compile\"],\n                flag_groups \u003d [\n                    flag_group (\n                        iterate_over \u003d \"module_files\",\n                        flags \u003d [\"-fmodule-file\u003d%{module_files}\"],\n                    )\n                ],\n            ),\n        ]\n    )\n  ]\n\nThis is quite verbose, but it avoids having to hardcode functionality directly into the build system.",
      "parentUuid": "6582b067_82479638",
      "range": {
        "startLine": 342,
        "startChar": 0,
        "endLine": 347,
        "endChar": 0
      },
      "revId": "9987886e61bb52e827aad9b02be356baf05b64a7",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac",
      "unresolved": true
    }
  ]
}