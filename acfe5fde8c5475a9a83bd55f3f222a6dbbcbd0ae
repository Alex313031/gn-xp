{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "f029b489_c14ec6de",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2025-07-29T13:55:15Z",
      "side": 1,
      "message": "I kind of don\u0027t love this. Not allowing newlines in string literals prevented a class of bugs where you accidentally forget a closing quote and things accidentally still parsed, but different than what you wanted. And wanting a newline in a string is rare, and as digit@ points out, it\u0027s already possible to do this in the rare case where it\u0027s needed.\n\nDo we really need this change?",
      "revId": "acfe5fde8c5475a9a83bd55f3f222a6dbbcbd0ae",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d13f3bc2_d291813e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1000030
      },
      "writtenOn": "2025-07-30T04:33:27Z",
      "side": 1,
      "message": "I think forgetting a closing quote can cause a significant parsing error, making it difficult to create a build that works incorrectly in a subtle way. Instead, it would probably fail loudly.\n\nThe main motivation for this change is to let users write more readable statements, especially in asserts, by using newlines easily. The current method for adding a newline is hard to find and less common than typical solutions like `\\n`. I think this difficulty tends to discourage developers from writing longer, more descriptive statements that would be more helpful.",
      "parentUuid": "f029b489_c14ec6de",
      "revId": "acfe5fde8c5475a9a83bd55f3f222a6dbbcbd0ae",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fb0c8365_1128b68f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2025-07-30T12:19:49Z",
      "side": 1,
      "message": "It\u0027s still a rare usecase, given we\u0027ve been living with the current state for a long time.\n\n(And in asserts, the formatting of a string with newlines will look weird. Usually you want to do some kind of \"ignore leading indent\" kind of feature to make the formatting nicer, etc.)\n\nAlmost no other language allows newlines in their strings, due to them not deeming the tradeoff worth it. Some have a *separate* form of string literals that allow newlines, so that you don\u0027t use them accidentally.\n\nAlso, the \"fail loudly\" error diagnostic is worse now, right?",
      "parentUuid": "d13f3bc2_d291813e",
      "revId": "acfe5fde8c5475a9a83bd55f3f222a6dbbcbd0ae",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d4374a17_e4d02ead",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1000005
      },
      "writtenOn": "2025-07-30T16:37:08Z",
      "side": 1,
      "message": "Personally, I think it\u0027s somewhat archaic to not allow newlines in literals, and I\u0027ve never seen someone (apart from Nico, now) make the claim that it\u0027s a tradeoff not worth making due to risk of errors. Instead, I think that languages haven\u0027t historically had them because it makes parsing the language more complicated; at least one example might be the fact that newlines can be different on different platforms (\\r vs \\n vs \\r\\n, etc.) and you might have to decide how to handle that difference. Having multiline literals also makes grepping for strings harder.\n\nCertainly more and more languages have added support for multiline literals over time, but I believe they use new syntax for that for backwards compatibility more than any other reason. \n\nI would be surprised if the concern Nico raises came up much if at all in practice (i.e., I agree with Takuto there), but I do think missing quotes can lead to weird error messages, which is close to what Nico suggests.\n\nThat said, I also don\u0027t think this\u0027d be used very much, and I don\u0027t think multiline literals are that useful unless they also have support for special processing of leading whitespace on a line, which this CL doesn\u0027t introduce, so I don\u0027t think it\u0027s that useful on its own. And unlike many or most languages (perhaps), I think there is limited to no utility for multiline string literals outside of debugging messages in GN.\n\nSo, I still think this is a good change, but I don\u0027t feel like it is so useful it absolutely should be made. A better change would probably include a convention for newline handling and leading whitespace, but that\u0027s probably more work than is really worth it.",
      "parentUuid": "fb0c8365_1128b68f",
      "revId": "acfe5fde8c5475a9a83bd55f3f222a6dbbcbd0ae",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "feb460cf_5206b6d5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1000102
      },
      "writtenOn": "2025-07-30T17:10:53Z",
      "side": 1,
      "message": "Accidental newline in string literal plus its error:\n\n```\n$ git diff\ndiff --git a/base/BUILD.gn b/base/BUILD.gn\nindex 723b60da9dd9a..44149fddd4db4 100644\n--- a/base/BUILD.gn\n+++ b/base/BUILD.gn\n@@ -178,7 +178,8 @@ component(\"base\") {\n     \"allocator/allocator_check.cc\",\n     \"allocator/allocator_check.h\",\n     \"allocator/dispatcher/configuration.h\",\n-    \"allocator/dispatcher/dispatcher.cc\",\n+    \"allocator/dispatcher/dispatcher.cc\n+\",\n     \"allocator/dispatcher/dispatcher.h\",\n     \"allocator/dispatcher/initializer.h\",\n     \"allocator/dispatcher/internal/dispatch_data.cc\",\n```\n\n```\n$ gn gen out/gn\nERROR at //base/BUILD.gn:181:5: Only source, header, and object files belong in the sources of a shared_library. //base/allocator/dispatcher/dispatcher.cc\n is not one of the valid types.\n```\n\nIf your terminal has just the right width, the newline in the output here is easy to miss.\n\nMissing closing quote:\n\n```\n$ git diff\ndiff --git a/base/BUILD.gn b/base/BUILD.gn\nindex 723b60da9dd9a..51f2bf991d0d8 100644\n--- a/base/BUILD.gn\n+++ b/base/BUILD.gn\n@@ -178,7 +178,7 @@ component(\"base\") {\n     \"allocator/allocator_check.cc\",\n     \"allocator/allocator_check.h\",\n     \"allocator/dispatcher/configuration.h\",\n-    \"allocator/dispatcher/dispatcher.cc\",\n+    \"allocator/dispatcher/dispatcher.cc,\n     \"allocator/dispatcher/dispatcher.h\",\n     \"allocator/dispatcher/initializer.h\",\n     \"allocator/dispatcher/internal/dispatch_data.cc\",\n```\n\n```\n$ gn gen out/gn\nERROR at //base/BUILD.gn:182:15: Invalid token.\n    \"allocator/dispatcher/dispatcher.h\",\n              ^\nI have no idea what this is.\n```\n\nThe diag points at what looks like a correct line in the snippet.\n\nThese seem like real regressions.\n\n\u003e because it makes parsing the language more complicated;\n\nScanning over \\n inside string literals isn\u0027t any harder than not doing it, is it?\n\nFWIW, the almighty statistical model agrees with my intuition: ...huh, apparently you can\u0027t share links to corp gemini chats. Anyways, prompt \"should programming languages support multi-line string literals? if so, should they have a dedicated literal type for that, or should they just support that in their normal string literal?\" Gemini Pro 2.5:\n\n\"\"\"\nModifying Normal Strings: A Flawed Alternative ðŸ‘Ž\n\n[...]\n\nDisadvantages of this approach:\n\nAmbiguity: Overloading a single syntax can be confusing. JavaScript\u0027s template literals (`) are used for both multi-line strings and expression interpolation (e.g., ${variable}), mixing two distinct features.\n\nLess Control: Simpler implementations might not offer intelligent handling of indentation, forcing developers to place the text flush against the left margin, which ruins code formatting.\n\nPotential for Errors: If a developer accidentally hits \"Enter\" in a regular string, it could either become an unintentional multi-line string or cause a syntax error, depending on the language\u0027s rules.\n\"\"\"\n\nOf course, you might get the opposite recommendation if you try it ;)",
      "parentUuid": "d4374a17_e4d02ead",
      "revId": "acfe5fde8c5475a9a83bd55f3f222a6dbbcbd0ae",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b10a432d_0be3a0c6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1000005
      },
      "writtenOn": "2025-07-30T18:42:51Z",
      "side": 1,
      "message": "I wasn\u0027t claiming you couldn\u0027t get errors with this, nor that there weren\u0027t tradeoffs (there are definitely tradeoffs).\n\nIn the first example, diagnosing the error would be a lot easier if the error message escaped the newline. One can imagine other error handling strategies that would be even better. You could probably fairly easily do something similar for the second example. You could also trivially semantically analyze the value and realize it was an invalid path (though that doesn\u0027t help with the second error). And returning better error messages is almost always a good idea. Even without that, though, I think devs would probably figure out these failure modes pretty quickly.\n\nThat said, doing the work for those improvements probably also makes the whole CL not worth it.\n\nI\u0027m not quite sure what you meant to achieve with the Gemini result; I\u0027m kind of hoping it was a joke :). I did indeed get different results, using public Gemini: Gemini 2.5 Flash gave me something fairly neutral which is pretty close to https://g.co/gemini/share/800fa91f540a. Gemini 2.5 Pro did indeed give me the opposite recommendation (\"Yes, programming languages should definitely support multi-line string literals...\"), though it recommended a separate quote token for multiline strings: https://g.co/gemini/share/eea5e6851160. \n\nRegardless, the machine\u0027s votes don\u0027t really convey any weight for me, one way or another :).",
      "parentUuid": "feb460cf_5206b6d5",
      "revId": "acfe5fde8c5475a9a83bd55f3f222a6dbbcbd0ae",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bf7df647_cb7a3429",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2025-07-30T19:17:16Z",
      "side": 1,
      "message": "\u003e That said, doing the work for those improvements probably also makes the whole CL not worth it.\n\nAgreed, and doing it without them imho makes it also not worth it :P\n\nAnyways, I said my piece, and if y\u0027all don\u0027t consider it convincing, then let\u0027s keep things as is. You\u0027re the OWNERS over here after all :)",
      "parentUuid": "b10a432d_0be3a0c6",
      "revId": "acfe5fde8c5475a9a83bd55f3f222a6dbbcbd0ae",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac"
    }
  ]
}