#!/usr/bin/env python3
# Copyright 2023 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""A script to query the file generated by `gn gen --ninja-outputs-file=FILE"""

import argparse
import json
import sys
from pathlib import Path
from typing import Dict, List


def read_input_file(args: argparse.Namespace) -> Dict[str, List[str]]:
    """Read the input file, either as JSON or as tabular data.

    Returns:
      A dictionary mapping GN label strings to lists of Ninja paths.
    """
    if args.format == "json":
        # Reading JSON input
        return json.load(args.input.open())
    else:
        # Reading tabular input into dictionary.
        result = {}
        assert args.format == "tabular"
        for line in args.input.read_text().splitlines():
            items = line.split("\t")
            if len(items) < 2:
                print("WARNING: Ignoring invalid line: {line}", file=sys.stderr)
                continue
            label = items[0]
            if label not in result:
                result[label] = items[1:]
            else:
                result[label].extend(items[1:])
        return result


def find_tabular_row_starting_with(content: bytes, key: bytes) -> bytes:
    """Find the row in a tabular input file with a given key.

    Args:
        content: input tabular file data, every row is terminated by a single
            newline, and TAB is used to separate values in each row.
            the rows must be sorted in increasing order of the first value.

        line_key: first item to look for in input rows.

    Returns:
        On success, a byte string corresponding to the row, without the
        newline terminator. On failure, an empty string.
    """

    NEWLINE = 10
    TAB = 9
    if False:
        # Linear scan. Keep this code here for debugging.
        # Benchmarking shows that this is only 10%-20% slower than bisection
        # on 40 MiB input files from Fuchsia build plans.
        content_len = len(content)
        content_pos = 0
        needle = key + b"\t"
        needle_len = len(needle)
        while content_pos < content_len:
            pos = content.find(needle, content_pos)
            if pos < 0:
                return b""
            if pos > 0 and content[pos - 1] != NEWLINE:
                # Mistmatch
                content_pos = pos + needle_len
                continue

            line_start = pos
            line_end = content.find(NEWLINE, pos + needle_len, content_len)
            if line_end < 0:
                line_end = content_len
            return content[line_start:line_end]

    else:
        # Bisection, since the lines are sorted by key (i.e. first column).
        lo = 0
        hi = len(content)
        while lo < hi:
            mid = (lo + hi) // 2
            cur_line_start = content.rfind(NEWLINE, lo, mid)
            if cur_line_start < 0:
                cur_line_start = lo
            else:
                cur_line_start += 1
            cur_line_end = content.find(NEWLINE, cur_line_start, hi)
            if cur_line_end < 0:
                cur_line_end = hi
            first_tab = content.find(TAB, cur_line_start, cur_line_end)
            line_key = content[cur_line_start:first_tab]
            if line_key == key:
                return content[cur_line_start:cur_line_end]
            if line_key < key:
                lo = cur_line_end + 1
            else:
                hi = cur_line_start

    return b""


def find_tabular_rows_containing_value(content: bytes, value: bytes) -> List[bytes]:
    """Find all rows in a tabular input file which contain a given value.

    Args:
        content: input tabular file data, see comment above for format details.
        value: value to look for in each row, past the first item of each row.

    Returns:
        A list of strings, one per matching row, without any newline
        terminators. On failure, an empty string is returned.
    """
    NEWLINE = 10
    TAB = 9
    result = []
    value_len = len(value)
    content_len = len(content)
    content_pos = 0
    while content_pos < content_len:
        pos = content.find(value, content_pos)
        if pos < 0:
            break

        # Found it, check boundaries.
        if (
            pos == 0
            or content[pos - 1] != TAB
            or content[pos + value_len] not in (NEWLINE, TAB)
        ):
            # Mistmatch.
            content_pos = pos + value_len
            continue

        # Find line start and end.
        line_start = content.rfind(NEWLINE, 0, pos)
        if line_start < 0:
            line_start = 0
        else:
            line_start += 1
        line_end = content.find(NEWLINE, pos, content_len)
        if line_end < 0:
            line_end = content_len

        result.append(content[line_start:line_end])
        content_pos = line_end

    return result


def print_paths_command(args: argparse.Namespace) -> int:
    """Implement the print_paths command."""
    paths = []
    if args.format == "tabular":
        # Optimized algorithm that uses binary searching without constructing
        # a dictionary in memory. Much faster than the naive version below,
        # e.g. 81ms vs 450ms
        input_content = args.input.read_bytes()
        line = find_tabular_row_starting_with(input_content, args.label.encode())
        if line:
            items = line.split(b"\t")
            assert len(items) >= 2, f"Invalid input file format, line: [{line}]"
            paths = [i.decode() for i in items[1:]]
    else:
        outputs_map = read_input_file(args)
        paths = outputs_map.get(args.label)

    if not paths:
        print(f"ERROR: {args.label} is not in input map key.", file=sys.stderr)
        return 1

    for path in paths:
        print(path)

    return 0


def print_labels_command(args: argparse.Namespace) -> int:
    """Implement the print_labels command."""
    labels = []
    if args.format == "tabular":
        # For tabular data, a simple linear scan is much faster than trying
        # to create any type of in-memory Python dict.
        # e.g. 110ms vs 380ms for the native version below.
        input_content = args.input.read_bytes()
        lines = find_tabular_rows_containing_value(input_content, args.path.encode())
        for line in lines:
            items = line.split(b"\t")
            assert len(items) >= 2, f"Invalid input file format, line [{line}]"
            labels.append(items[0].decode())
    else:
        outputs_map = read_input_file(args)
        for label, path_list in outputs_map.items():
            if args.path in path_list:
                labels.append(label)

    if not labels:
        print(f"ERROR: {args.path} is not an input map value.", file=sys.stderr)
        return 1

    for label in labels:
        print(label)
    return 0


def main(args):
    parser = argparse.ArgumentParser(description=__doc__)

    parser.add_argument(
        "--input", required=True, type=Path, help="Ninja outputs file generated by GN."
    )
    parser.add_argument(
        "--format",
        choices=("auto", "json", "tabular"),
        default="auto",
        help="Format of input file (auto-detected based on file extension).",
    )

    subparsers = parser.add_subparsers()
    print_paths_parser = subparsers.add_parser(
        "print_paths", help="Convert GN label into list of Ninja paths"
    )
    print_paths_parser.add_argument("label", help="GN label")
    print_paths_parser.set_defaults(func=print_paths_command)

    print_labels_parser = subparsers.add_parser(
        "print_labels", help="Convert Ninja target path into one or more GN labels"
    )
    print_labels_parser.add_argument("path", help="Ninja output path")
    print_labels_parser.set_defaults(func=print_labels_command)

    args = parser.parse_args()

    if args.format == "auto":
        if str(args.input).endswith(".json"):
            args.format = "json"
        elif str(args.input).endswith(".txt"):
            args.format = "tabular"
        else:
            parser_error("Cannot auto-detect input file format, please use --format!")

    return args.func(args)


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
