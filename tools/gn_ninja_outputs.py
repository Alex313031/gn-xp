#!/usr/bin/env python3
# Copyright 2023 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""A script to query the file generated by `gn gen --ninja-outputs-file=FILE"""

import argparse
import json
import sys
from pathlib import Path
from typing import Dict, List


class OutputsIndexFile(object):
    """Implement a fast index file format for querying labels and paths.

    Usage is the following:

       1) Create instance.
       2) Call load_from_json() or load_from_file()
       3) Call get_labels_for_path() or get_paths_for_label() to perform queries.
       4) Optional: call write_to_file() to write to binary file.
    """

    # Four bytes at the start of the file to recognize its format.
    # This is followed by newline-separated rows, where each row follows
    # the format of:
    #
    #     <label> <tab> <path1> [<tab> <path2> ...]
    #
    # Where <label> is a GN label, and <path1>, <path2>, ... are corresponding output
    # file paths. The final row always includes a trailing newline.
    INDEX_MAGIC: str = "\x08IDX"

    def __init__(self):
        self._content: str = ""

    def load_from_json(self, input_path: Path):
        """Load input JSON file into runtime index."""
        input_json = json.load(input_path.open())
        content = ""
        for label, paths in input_json.items():
            row = label
            for path in paths:
                row += "\t"
                row += path
            row += "\n"
            content += row
        self._content = content

    def write_to_file(self, output_path: Path):
        """Write to a file for later use with load_from_file()."""
        with output_path.open("wt") as f:
            f.write(self.INDEX_MAGIC)
            f.write(self._content)

    def load_from_file(self, input_path: Path) -> bool:
        """Load from index file generated by write_to_file()"""
        data = input_path.read_text()
        magic = data[0:4]
        if magic != self.INDEX_MAGIC:
            return False
        self._content = data[4:]
        return True

    def get_labels_for_path(self, path: str) -> List[str]:
        """Return the list of labels that produce a given Ninja output path.

        Args:
            path: Ninja output path, as it appears in the Ninja build manifest.
        Returns:
            A list of labels. List is empty if there is no corresponding path
            in the map. There will be more than two items if several labels
            generate the same output file (which should be an error).
        """
        labels = []
        # For index data, a simple linear scan is much faster than trying
        # to create any type of in-memory Python dict.
        # e.g. 110ms vs 380ms for the native version below.
        lines = self._find_rows_containing_value(path)
        for line in lines:
            items = line.split("\t")
            assert len(items) >= 2, f"Invalid input file format, line [{line}]"
            labels.append(items[0])
        return labels

    def get_paths_for_label(self, label: str) -> List[str]:
        """Return the list of paths generated by a given GN label.

        Args:
          label: GN label as it appears in the original JSON output path.
             fully qualified, but will not have a toolchain suffix for the
             default toolchain.

        Returns:
          A list of Ninja output file paths. Empty if the label is unknown.
        """
        paths = []
        line = self._find_row_starting_with(self._content, label)
        if line:
            items = line.split("\t")
            assert len(items) >= 2, f"Invalid input file format, line: [{line}]"
            paths = items[1:]

        return paths

    def _find_row_starting_with(self, key: str) -> str:
        """Find the row in a index input file with a given key.

        Args:
            key: first item to look for in input rows.

        Returns:
            On success, a byte string corresponding to the row, without the
            newline terminator. On failure, an empty string.
        """
        # Use local variable to avoid self -> _content dereference on each use.
        content = self._content
        if False:
            # Linear scan. Keep this code here for debugging.
            # Benchmarking shows that this is only 10%-20% slower than bisection
            # on 40 MiB input files from Fuchsia build plans.
            content_len = len(content)
            content_pos = 0
            needle = key + "\t"
            needle_len = len(needle)
            while content_pos < content_len:
                pos = content.find(needle, content_pos)
                if pos < 0:
                    return ""
                if pos > 0 and self._content[pos - 1] != "\n":
                    # Mistmatch
                    content_pos = pos + needle_len
                    continue

                line_start = pos
                line_end = content.find("\n", pos + needle_len, content_len)
                if line_end < 0:
                    line_end = content_len
                return content[line_start:line_end]

        else:
            # Bisection, since the lines are sorted by key (i.e. first column).
            lo = 0
            hi = len(content)
            while lo < hi:
                mid = (lo + hi) // 2
                cur_line_start = content.rfind("\n", lo, mid)
                if cur_line_start < 0:
                    cur_line_start = lo
                else:
                    cur_line_start += 1
                cur_line_end = content.find("\n", cur_line_start, hi)
                if cur_line_end < 0:
                    cur_line_end = hi
                first_tab = content.find("\t", cur_line_start, cur_line_end)
                line_key = content[cur_line_start:first_tab]
                if line_key == key:
                    return content[cur_line_start:cur_line_end]
                if line_key < key:
                    lo = cur_line_end + 1
                else:
                    hi = cur_line_start

        return b""

    def _find_rows_containing_value(self, value: str) -> List[str]:
        """Find all rows in a index file which contain a given value.

        Args:
            value: value to look for in each row, past the first item of each row.

        Returns:
            A list of strings, one per matching row, without any newline
            terminators. On failure, an empty string is returned.
        """
        # Use local variable for performance.
        content = self._content
        # These two constant variables are not used in the real code for performance reason.
        result = []
        value_len = len(value)
        content_len = len(content)
        content_pos = 0
        while content_pos < content_len:
            pos = content.find(value, content_pos)
            if pos < 0:
                break

            # Found it, check boundaries.
            if (
                pos == 0
                or content[pos - 1] != "\t"
                or content[pos + value_len] not in "\t\n"
            ):
                # Mistmatch.
                content_pos = pos + value_len
                continue

            # Find line start and end.
            line_start = content.rfind("\n", 0, pos)
            if line_start < 0:
                line_start = 0
            else:
                line_start += 1
            line_end = content.find("\n", pos, content_len)
            if line_end < 0:
                line_end = content_len

            result.append(content[line_start:line_end])
            content_pos = line_end

        return result


def get_label_for_path(path: str, input_path: Path, format: str) -> str:
    """Find the GN labels matching a given Ninja path.

    Args:
        path: Ninja path as it appears in the Ninja build plan.
        input_path: Path to the input outputs file.
        format: Format type, either "index" or "json".
    Returns:
        A GN label string, or None if there is no corresponding label.
    """
    labels = []
    if format == "index":
        index = OutputsIndexFile()
        if not index.load_from_file(input_path):
            assert False, f"Invalid index file format: {input_path}"

        labels = index.get_labels_for_path(path)
    else:
        outputs_map = json.load(input_path.open())
        for label, path_list in outputs_map.items():
            if path in path_list:
                labels.append(label)

    if not labels:
        return None

    assert len(labels) == 1, f"{path} is generated by more than one GN label: {labels}"
    return labels[0]


def get_paths_for_label(label: str, input_path: Path, format: str) -> List[str]:
    paths = []
    if format == "index":
        # Optimized algorithm that uses binary searching without constructing
        # a dictionary in memory. Much faster than the naive version below,
        # e.g. 81ms vs 450ms
        index = OutputsIndexFile()
        if not index.load_from_file(input_path):
            assert False, f"Invalid index file format: {input_path}"
        paths = index.get_paths_for_label(label)
    elif format == "json":
        outputs_map = json.load(input_path.open())
        paths = outputs_map.get(label)
    else:
        assert False, f"Invalid format argument: {format}"

    return paths


def print_paths_command(args: argparse.Namespace) -> int:
    """Implement the print_paths command."""
    paths = get_paths_for_label(args.label, args.input, args.format)

    if not paths:
        print(f"ERROR: {args.label} is not in input map key.", file=sys.stderr)
        return 1

    for path in paths:
        print(path)

    return 0


def print_label_command(args: argparse.Namespace) -> int:
    """Implement the print_label command."""
    try:
        label = get_label_for_path(args.path, args.input, args.format)
    except Exception as e:
        print(str(e), file=sys.stderr)
        raise e

    if not label:
        print(f"ERROR: Unknonw Ninja target path: {args.path}", file=sys.stderr)
        return 1

    print(label)
    return 0


def generate_index_command(args: argparse.Namespace) -> int:
    index = OutputsIndexFile()
    index.load_from_json(args.input)
    index.write_to_file(args.output_file)
    return 0


def main(args):
    parser = argparse.ArgumentParser(description=__doc__)

    parser.add_argument(
        "--input",
        required=True,
        type=Path,
        help="GN ninja outputs JSON file, or binary index file from generate_index command.",
    )
    parser.add_argument(
        "--format",
        choices=("auto", "json", "index"),
        default="auto",
        help="Format of input file (auto-detected based on file extension).",
    )

    subparsers = parser.add_subparsers()
    print_paths_parser = subparsers.add_parser(
        "print_paths", help="Convert GN label into list of Ninja paths"
    )
    print_paths_parser.add_argument("label", help="GN label")
    print_paths_parser.set_defaults(func=print_paths_command)

    print_label_parser = subparsers.add_parser(
        "print_label", help="Convert Ninja target path into one or more GN labels"
    )
    print_label_parser.add_argument("path", help="Ninja output path")
    print_label_parser.set_defaults(func=print_label_command)

    generate_index_parser = subparsers.add_parser(
        "generate_index",
        help="Convert GN-generated JSON file into binary index for faster queries.",
    )
    generate_index_parser.add_argument(
        "output_file", type=Path, help="Output index file path."
    )
    generate_index_parser.set_defaults(func=generate_index_command)

    args = parser.parse_args()

    if args.format == "auto":
        if str(args.input).endswith(".json"):
            args.format = "json"
        else:
            args.format = "index"

    return args.func(args)


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
