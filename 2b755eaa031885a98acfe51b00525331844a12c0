{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "9b8b973f_958d25b8",
        "filename": "src/gn/ninja_c_binary_target_writer_unittest.cc",
        "patchSetId": 23
      },
      "lineNbr": 1472,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2022-03-24T19:51:14Z",
      "side": 1,
      "message": "The name pub_sset_in_staticlib seems misleading given it\u0027s a private dep (and not a direct dep of the staticlib).. if not a different (albeit probably longer) name, I think it at least deserves a comment explaining the name.",
      "revId": "2b755eaa031885a98acfe51b00525331844a12c0",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ac4e02eb_98f9b263",
        "filename": "src/gn/ninja_c_binary_target_writer_unittest.cc",
        "patchSetId": 23
      },
      "lineNbr": 1562,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2022-03-24T19:51:14Z",
      "side": 1,
      "message": "I don\u0027t think this should be here, because Rust staticlibs are \"complete\" in that they include all dependencies according to the rustc docs. (At least all Rust dependencies, I doubt they include native dependencies.)\n\n\u003e The purpose of this output type is to create a static library containing all of the local crate\u0027s code along with all upstream dependencies. ... This format is recommended for use in situations such as linking Rust code into an existing non-Rust application because it will not have dynamic dependencies on other Rust code.\n\nhttps://doc.rust-lang.org/reference/linkage.html\n\nThis shows up in a couple other tests too.",
      "revId": "2b755eaa031885a98acfe51b00525331844a12c0",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7e9d58cf_7cf49d62",
        "filename": "src/gn/ninja_c_binary_target_writer_unittest.cc",
        "patchSetId": 23
      },
      "lineNbr": 1619,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2022-03-24T19:51:14Z",
      "side": 1,
      "message": "I was imagining a use case where a proc macro depends on supporting library for code it injects to work. That supporting library needs to be depended on by any code that uses this proc macro.\n\nBut it\u0027s not really a great fit because the proc macro *itself* doesn\u0027t depend on that library (which might not even compile for the host platform). So it\u0027s probably correct that we don\u0027t propagate public deps of proc macros, but it\u0027s pretty subtle and perhaps surprising.\n\nOr maybe the answer should be that we do propagate these deps as with other target types, but it\u0027s almost always the wrong thing for a user to do? At least things would be more consistent. Either way, public_deps on proc macros seem mostly useless?\n\nSorry to relitigate this question here. I want to make sure I understand the tradeoffs.",
      "revId": "2b755eaa031885a98acfe51b00525331844a12c0",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0d1d28ff_234e17d7",
        "filename": "src/gn/ninja_rust_binary_target_writer_unittest.cc",
        "patchSetId": 23
      },
      "lineNbr": 894,
      "author": {
        "id": 1000168
      },
      "writtenOn": "2022-03-24T19:51:14Z",
      "side": 1,
      "message": "This test is much more readable than other tests in this file thanks to your consistent naming of the targets and their outputs. Thank you!",
      "revId": "2b755eaa031885a98acfe51b00525331844a12c0",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac"
    }
  ]
}