{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "3d8e949e_74ea2908",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001498
      },
      "writtenOn": "2022-06-25T06:31:34Z",
      "side": 1,
      "message": "Brett, I\u0027m OOO next week so it\u0027s a good opportunity to get early feedback on this while I\u0027m out. Feel free to forward to other reviewers as appropriate. This is largely done, but I want to test it in situ a bit more than I had a chance to today. The commit message has one REVIEW TODO scenario that may require a change in NinjaBuildWriter. Also need to make a pass to check if there\u0027s any other new unit tests warranted.",
      "revId": "1829111773933ed7a8dc669016010d3ef9d5a44d",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6dd870bc_a7de343c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000014
      },
      "writtenOn": "2022-07-07T20:23:46Z",
      "side": 1,
      "message": "I was thinking GN would always write the new build in the .tmp file and then as a last step would remove the old build.ninja file and move the new one in place.\n\nI think this will be a lot simpler. The delete + rename should be fast enough that there will be almost no opportunity to get partial state in practice.",
      "revId": "1829111773933ed7a8dc669016010d3ef9d5a44d",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fbae0ea2_35f6eb4c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000014
      },
      "writtenOn": "2022-07-07T20:23:59Z",
      "side": 1,
      "message": "Thanks for looking at this, BTW!",
      "revId": "1829111773933ed7a8dc669016010d3ef9d5a44d",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "85123e38_d366d288",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001498
      },
      "writtenOn": "2022-07-07T23:37:21Z",
      "side": 1,
      "message": "I\u0027m not sure I understand what change you\u0027re suggesting. The key to this fix is splitting the ninja steps in two, so that ninja won\u0027t delete the build.ninja if interrupted (only the .tmp) while still having the build.ninja.d depfile in build.ninja\u0027s dependency tree (now through the .tmp step). That means the .tmp needs to still exist once regeneration is done, it can\u0027t be renamed to build.ninja.\n\nAm I missing your suggestion here?",
      "parentUuid": "6dd870bc_a7de343c",
      "revId": "1829111773933ed7a8dc669016010d3ef9d5a44d",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8546f24f_1a309f57",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000014
      },
      "writtenOn": "2022-07-08T18:04:32Z",
      "side": 1,
      "message": "My suggestion is to do this unconditionally within one run of GN:\n\n  1. Step one of any \"gn gen\" run would be to write a new build.ninja with just a rule to re-run gn. This would be the current regeneration rule (you shouldn\u0027t need to write a new copy rule as I describe below).\n\n  2. Then the entire build would be generated, writing the new root build.ninja to the side like you do.\n\n  3. Then GN would delete the old build.ninja and move the new one into place.\n\nI don\u0027t think you need to worry about whether the run is a regeneration or not: all of these steps can be performed unconditionally. You can make a new build with `gn gen --args\u003d\"foo\u003dbar\"` and interrupt that, and it will generate an unusable build just like it would in the interrupted regeneration case.\n\nYou don\u0027t need to express the copy in terms of Ninja. GN can itself delete the old file and move the new one over it. The move should be much more atomic (the file is large so copying will leave plenty of chance for interruption). It should also simplify your code since you don\u0027t need to write the new copy rule.\n\nI also don\u0027t think you need to read the .ninja file explicitly for \"gn gen\". With the existing code, it just writes the current process\u0027 command line arguments which should be propagated through the reinvocation command from Ninja and I think this should continue to work.\n\nThere an argument for what it should do when you explicitly run \"gn gen\" on an existing directory. Currently, it will clobber your command-line options but keep your args.gn. Sometimes you might want to use the old command-line arguments even though you didn\u0027t specify them on this gen run. But you can also specify new ones! I think there\u0027s an inherent conflict here and I concluded the answer is \"don\u0027t do that\" (I think few people even know about this so it\u0027s fine).\n\nHowever, preserving the old command line args in the \"gn clean\" case like you do is a nice addition and there is no opportunity for conflict, so I think we should keep that for sure.",
      "parentUuid": "85123e38_d366d288",
      "revId": "1829111773933ed7a8dc669016010d3ef9d5a44d",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "71ff8200_a1e40e27",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001498
      },
      "writtenOn": "2022-07-08T18:48:49Z",
      "side": 1,
      "message": "I think there\u0027s some confusion about what I\u0027m trying to fix with this change.\n\n\u003e My suggestion is to do this unconditionally within one run of GN:\n\nThat flow would not resolve the bug that I\u0027m fixing here. The goal here is to ensure that ninja does not delete build.ninja when regeneration is interrupted. Today, that deletion happens because the \"build build.ninja\" statement directly uses a depfile (build.ninja.d). Since the deletion is performed by ninja, changes to GN without any modification of the generated ninja rules cannot prevent that deletion.\n\nCould you read your comments from the bug again, perhaps? Specifically:\n\n\"The best solution-without-changing ninja that I came up with is to have the build regen be responsible for building build.ninja.tmp that uses the depfile, and a second edge that just copies build.ninja.tmp to build.ninja (but doesn\u0027t use a depfile).\"\n\nSplitting the ninja rules in this way, as you\u0027d suggested back in 2018 on the bug, is the only way I can think of to get around ninja\u0027s \"delete all outputs during cleanup if a depfile is used, even if they weren\u0027t modified\" logic.\n\n\u003e You can make a new build with  gn gen --args\u003d\"foo\u003dbar\"  and interrupt that, and it will generate an unusable build just like it would in the interrupted regeneration case.\n\nInterrupting a fresh \"gn gen\" is most likely to result in no build.ninja being written at all, because that and the depfile are written last. This is not the same scenario as what I\u0027m trying to fix. The problem that I\u0027m trying to fix is *ninja* deleting the build.ninja file, whether it was modified or not, simply because that build edge uses a depfile. The end result looks similar - no build.ninja - but the cause is not the same.\n\n\u003e You don\u0027t need to express the copy in terms of Ninja. GN can itself delete the old file and move the new one over it.\n\nAs I mentioned above, the two separate ninja build statements are the key to fixing this bug. It\u0027s possible there is some other arrangement of ninja build statements that would also resolve this bug without the need for the build.ninja.tmp -\u003e build.ninja copy, but none has occurred to me yet. I\u0027ll think about it some more.\n\n\u003e I also don\u0027t think you need to read the .ninja file explicitly for \"gn gen\".\n\nThis was from me reusing the logic from \"gn clean\", but I guess there\u0027s no benefit to doing so when we have the flags available on the command line. I\u0027ll replace this and then this step doesn\u0027t need to be dependent on regeneration.\n\n\u003e I don\u0027t think you need to worry about whether the run is a regeneration or not\n\nAgreed, if I stop borrowing the logic from \"clean\" I no longer need to.\n\n\u003e However, preserving the old command line args in the \"gn clean\" case like you do is a nice addition\n\nThat wasn\u0027t an addition; \"gn clean\" already does that. Reading the .ninja file and stripping out the regeneration commands was me borrowing the logic from \"clean\" to reuse for \"gen\" (and cleaning it up a bit, since it relied on a magic number with no tests behind it).",
      "parentUuid": "8546f24f_1a309f57",
      "revId": "1829111773933ed7a8dc669016010d3ef9d5a44d",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "31fad7b0_a280e78e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001498
      },
      "writtenOn": "2022-07-08T19:19:36Z",
      "side": 1,
      "message": "\u003e It\u0027s possible there is some other arrangement of ninja build statements that would also resolve this bug without the need for the build.ninja.tmp -\u003e build.ninja copy, but none has occurred to me yet. I\u0027ll think about it some more.\n\nThinking out loud...\n\nOne limitation here are the tools that we have available from the toolchain, which for basic file operations are copy and stamp. We don\u0027t *really* need ninja to copy build.ninja.tmp -\u003e build.ninja because (as I noted in the REVIEW TODO in my commit message) \"gn gen\" needs to write build.ninja unconditionally anyway.\n\nTwo possible ideas:\n\n1. The new \"build build.ninja\" statement could use a no-op rule instead, if there\u0027s a way to write a cross-platform no-op rule (without relying on the toolchain). I wonder if the phony rule would work here...I\u0027ll try it.\n\n2. If that first idea works, we don\u0027t actually need to write the real contents to build.ninja.tmp at all because it\u0027ll never be used.\n\nMaybe something like this will work? The trick here is that \"gn gen\" is managing overwriting build.ninja - first with just the regeneration commands, then the full contents - without ninja being aware, i.e. even though these ninja rules might make you think it\u0027s doing no such thing in the \"regenerate\" edge. I\u0027ll try it out.\n\n```\n  build regenerate: gn\n    depfile \u003d build.ninja.d\n\n  build build.ninja: phony regenerate\n    generator \u003d 1\n```",
      "parentUuid": "71ff8200_a1e40e27",
      "revId": "1829111773933ed7a8dc669016010d3ef9d5a44d",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7b2aa2b6_fb01913d",
        "filename": "src/gn/ninja_build_writer.cc",
        "patchSetId": 1
      },
      "lineNbr": 296,
      "author": {
        "id": 1000014
      },
      "writtenOn": "2022-07-08T18:04:32Z",
      "side": 1,
      "message": "This shadows the path for the .tmp file with a different value. Probably these should have different names that describe what they are.",
      "range": {
        "startLine": 296,
        "startChar": 19,
        "endLine": 296,
        "endChar": 34
      },
      "revId": "1829111773933ed7a8dc669016010d3ef9d5a44d",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "63397246_c79b5e00",
        "filename": "src/gn/ninja_build_writer.cc",
        "patchSetId": 1
      },
      "lineNbr": 296,
      "author": {
        "id": 1001498
      },
      "writtenOn": "2022-07-08T18:48:49Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "7b2aa2b6_fb01913d",
      "range": {
        "startLine": 296,
        "startChar": 19,
        "endLine": 296,
        "endChar": 34
      },
      "revId": "1829111773933ed7a8dc669016010d3ef9d5a44d",
      "serverId": "c360c8e5-7aa8-3905-a7a0-810934766dac"
    }
  ]
}